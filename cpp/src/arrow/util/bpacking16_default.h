#pragma once

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// This file was generated by script which is modified from its original version in
// GitHub. Original source:
// https://github.com/lemire/FrameOfReference/blob/146948b6058a976bc7767262ad3a2ce201486b93/scripts/turbopacking64.py
// The original copyright notice follows.

// This code is released under the
// Apache License Version 2.0 http://www.apache.org/licenses/.
// (c) Daniel Lemire 2013

#pragma once

#include "arrow/util/bit_util.h"
#include "arrow/util/ubsan.h"

namespace arrow {
namespace internal {

inline const uint8_t* unpack0_16(const uint8_t* in, uint16_t* out) {
  for (int k = 0; k < 32; k += 1) {
    out[k] = 0;
  }
  return in;
}

inline const uint8_t* unpack1_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 1ULL;
  uint64_t w0 = util::SafeLoadAs<uint32_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 4;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 1) & mask;
  out[2] = (w0 >> 2) & mask;
  out[3] = (w0 >> 3) & mask;
  out[4] = (w0 >> 4) & mask;
  out[5] = (w0 >> 5) & mask;
  out[6] = (w0 >> 6) & mask;
  out[7] = (w0 >> 7) & mask;
  out[8] = (w0 >> 8) & mask;
  out[9] = (w0 >> 9) & mask;
  out[10] = (w0 >> 10) & mask;
  out[11] = (w0 >> 11) & mask;
  out[12] = (w0 >> 12) & mask;
  out[13] = (w0 >> 13) & mask;
  out[14] = (w0 >> 14) & mask;
  out[15] = (w0 >> 15) & mask;
  out[16] = (w0 >> 16) & mask;
  out[17] = (w0 >> 17) & mask;
  out[18] = (w0 >> 18) & mask;
  out[19] = (w0 >> 19) & mask;
  out[20] = (w0 >> 20) & mask;
  out[21] = (w0 >> 21) & mask;
  out[22] = (w0 >> 22) & mask;
  out[23] = (w0 >> 23) & mask;
  out[24] = (w0 >> 24) & mask;
  out[25] = (w0 >> 25) & mask;
  out[26] = (w0 >> 26) & mask;
  out[27] = (w0 >> 27) & mask;
  out[28] = (w0 >> 28) & mask;
  out[29] = (w0 >> 29) & mask;
  out[30] = (w0 >> 30) & mask;
  out[31] = (w0 >> 31) & mask;

  return in;
}

inline const uint8_t* unpack2_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 3ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 2) & mask;
  out[2] = (w0 >> 4) & mask;
  out[3] = (w0 >> 6) & mask;
  out[4] = (w0 >> 8) & mask;
  out[5] = (w0 >> 10) & mask;
  out[6] = (w0 >> 12) & mask;
  out[7] = (w0 >> 14) & mask;
  out[8] = (w0 >> 16) & mask;
  out[9] = (w0 >> 18) & mask;
  out[10] = (w0 >> 20) & mask;
  out[11] = (w0 >> 22) & mask;
  out[12] = (w0 >> 24) & mask;
  out[13] = (w0 >> 26) & mask;
  out[14] = (w0 >> 28) & mask;
  out[15] = (w0 >> 30) & mask;
  out[16] = (w0 >> 32) & mask;
  out[17] = (w0 >> 34) & mask;
  out[18] = (w0 >> 36) & mask;
  out[19] = (w0 >> 38) & mask;
  out[20] = (w0 >> 40) & mask;
  out[21] = (w0 >> 42) & mask;
  out[22] = (w0 >> 44) & mask;
  out[23] = (w0 >> 46) & mask;
  out[24] = (w0 >> 48) & mask;
  out[25] = (w0 >> 50) & mask;
  out[26] = (w0 >> 52) & mask;
  out[27] = (w0 >> 54) & mask;
  out[28] = (w0 >> 56) & mask;
  out[29] = (w0 >> 58) & mask;
  out[30] = (w0 >> 60) & mask;
  out[31] = w0 >> 62;

  return in;
}

inline const uint8_t* unpack3_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 7ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint32_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 4;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 3) & mask;
  out[2] = (w0 >> 6) & mask;
  out[3] = (w0 >> 9) & mask;
  out[4] = (w0 >> 12) & mask;
  out[5] = (w0 >> 15) & mask;
  out[6] = (w0 >> 18) & mask;
  out[7] = (w0 >> 21) & mask;
  out[8] = (w0 >> 24) & mask;
  out[9] = (w0 >> 27) & mask;
  out[10] = (w0 >> 30) & mask;
  out[11] = (w0 >> 33) & mask;
  out[12] = (w0 >> 36) & mask;
  out[13] = (w0 >> 39) & mask;
  out[14] = (w0 >> 42) & mask;
  out[15] = (w0 >> 45) & mask;
  out[16] = (w0 >> 48) & mask;
  out[17] = (w0 >> 51) & mask;
  out[18] = (w0 >> 54) & mask;
  out[19] = (w0 >> 57) & mask;
  out[20] = (w0 >> 60) & mask;
  out[21] = ((w0 >> 63) | (w1 << 1)) & mask;
  out[22] = (w1 >> 2) & mask;
  out[23] = (w1 >> 5) & mask;
  out[24] = (w1 >> 8) & mask;
  out[25] = (w1 >> 11) & mask;
  out[26] = (w1 >> 14) & mask;
  out[27] = (w1 >> 17) & mask;
  out[28] = (w1 >> 20) & mask;
  out[29] = (w1 >> 23) & mask;
  out[30] = (w1 >> 26) & mask;
  out[31] = (w1 >> 29) & mask;

  return in;
}

inline const uint8_t* unpack4_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 15ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 4) & mask;
  out[2] = (w0 >> 8) & mask;
  out[3] = (w0 >> 12) & mask;
  out[4] = (w0 >> 16) & mask;
  out[5] = (w0 >> 20) & mask;
  out[6] = (w0 >> 24) & mask;
  out[7] = (w0 >> 28) & mask;
  out[8] = (w0 >> 32) & mask;
  out[9] = (w0 >> 36) & mask;
  out[10] = (w0 >> 40) & mask;
  out[11] = (w0 >> 44) & mask;
  out[12] = (w0 >> 48) & mask;
  out[13] = (w0 >> 52) & mask;
  out[14] = (w0 >> 56) & mask;
  out[15] = w0 >> 60;
  out[16] = (w1)&mask;
  out[17] = (w1 >> 4) & mask;
  out[18] = (w1 >> 8) & mask;
  out[19] = (w1 >> 12) & mask;
  out[20] = (w1 >> 16) & mask;
  out[21] = (w1 >> 20) & mask;
  out[22] = (w1 >> 24) & mask;
  out[23] = (w1 >> 28) & mask;
  out[24] = (w1 >> 32) & mask;
  out[25] = (w1 >> 36) & mask;
  out[26] = (w1 >> 40) & mask;
  out[27] = (w1 >> 44) & mask;
  out[28] = (w1 >> 48) & mask;
  out[29] = (w1 >> 52) & mask;
  out[30] = (w1 >> 56) & mask;
  out[31] = w1 >> 60;

  return in;
}

inline const uint8_t* unpack5_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 31ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint32_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 4;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 5) & mask;
  out[2] = (w0 >> 10) & mask;
  out[3] = (w0 >> 15) & mask;
  out[4] = (w0 >> 20) & mask;
  out[5] = (w0 >> 25) & mask;
  out[6] = (w0 >> 30) & mask;
  out[7] = (w0 >> 35) & mask;
  out[8] = (w0 >> 40) & mask;
  out[9] = (w0 >> 45) & mask;
  out[10] = (w0 >> 50) & mask;
  out[11] = (w0 >> 55) & mask;
  out[12] = ((w0 >> 60) | (w1 << 4)) & mask;
  out[13] = (w1 >> 1) & mask;
  out[14] = (w1 >> 6) & mask;
  out[15] = (w1 >> 11) & mask;
  out[16] = (w1 >> 16) & mask;
  out[17] = (w1 >> 21) & mask;
  out[18] = (w1 >> 26) & mask;
  out[19] = (w1 >> 31) & mask;
  out[20] = (w1 >> 36) & mask;
  out[21] = (w1 >> 41) & mask;
  out[22] = (w1 >> 46) & mask;
  out[23] = (w1 >> 51) & mask;
  out[24] = (w1 >> 56) & mask;
  out[25] = ((w1 >> 61) | (w2 << 3)) & mask;
  out[26] = (w2 >> 2) & mask;
  out[27] = (w2 >> 7) & mask;
  out[28] = (w2 >> 12) & mask;
  out[29] = (w2 >> 17) & mask;
  out[30] = (w2 >> 22) & mask;
  out[31] = (w2 >> 27) & mask;

  return in;
}

inline const uint8_t* unpack6_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 63ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 6) & mask;
  out[2] = (w0 >> 12) & mask;
  out[3] = (w0 >> 18) & mask;
  out[4] = (w0 >> 24) & mask;
  out[5] = (w0 >> 30) & mask;
  out[6] = (w0 >> 36) & mask;
  out[7] = (w0 >> 42) & mask;
  out[8] = (w0 >> 48) & mask;
  out[9] = (w0 >> 54) & mask;
  out[10] = ((w0 >> 60) | (w1 << 4)) & mask;
  out[11] = (w1 >> 2) & mask;
  out[12] = (w1 >> 8) & mask;
  out[13] = (w1 >> 14) & mask;
  out[14] = (w1 >> 20) & mask;
  out[15] = (w1 >> 26) & mask;
  out[16] = (w1 >> 32) & mask;
  out[17] = (w1 >> 38) & mask;
  out[18] = (w1 >> 44) & mask;
  out[19] = (w1 >> 50) & mask;
  out[20] = (w1 >> 56) & mask;
  out[21] = ((w1 >> 62) | (w2 << 2)) & mask;
  out[22] = (w2 >> 4) & mask;
  out[23] = (w2 >> 10) & mask;
  out[24] = (w2 >> 16) & mask;
  out[25] = (w2 >> 22) & mask;
  out[26] = (w2 >> 28) & mask;
  out[27] = (w2 >> 34) & mask;
  out[28] = (w2 >> 40) & mask;
  out[29] = (w2 >> 46) & mask;
  out[30] = (w2 >> 52) & mask;
  out[31] = w2 >> 58;

  return in;
}

inline const uint8_t* unpack7_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 127ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint32_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 4;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 7) & mask;
  out[2] = (w0 >> 14) & mask;
  out[3] = (w0 >> 21) & mask;
  out[4] = (w0 >> 28) & mask;
  out[5] = (w0 >> 35) & mask;
  out[6] = (w0 >> 42) & mask;
  out[7] = (w0 >> 49) & mask;
  out[8] = (w0 >> 56) & mask;
  out[9] = ((w0 >> 63) | (w1 << 1)) & mask;
  out[10] = (w1 >> 6) & mask;
  out[11] = (w1 >> 13) & mask;
  out[12] = (w1 >> 20) & mask;
  out[13] = (w1 >> 27) & mask;
  out[14] = (w1 >> 34) & mask;
  out[15] = (w1 >> 41) & mask;
  out[16] = (w1 >> 48) & mask;
  out[17] = (w1 >> 55) & mask;
  out[18] = ((w1 >> 62) | (w2 << 2)) & mask;
  out[19] = (w2 >> 5) & mask;
  out[20] = (w2 >> 12) & mask;
  out[21] = (w2 >> 19) & mask;
  out[22] = (w2 >> 26) & mask;
  out[23] = (w2 >> 33) & mask;
  out[24] = (w2 >> 40) & mask;
  out[25] = (w2 >> 47) & mask;
  out[26] = (w2 >> 54) & mask;
  out[27] = ((w2 >> 61) | (w3 << 3)) & mask;
  out[28] = (w3 >> 4) & mask;
  out[29] = (w3 >> 11) & mask;
  out[30] = (w3 >> 18) & mask;
  out[31] = (w3 >> 25) & mask;

  return in;
}

inline const uint8_t* unpack8_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 255ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint64_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 8;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 8) & mask;
  out[2] = (w0 >> 16) & mask;
  out[3] = (w0 >> 24) & mask;
  out[4] = (w0 >> 32) & mask;
  out[5] = (w0 >> 40) & mask;
  out[6] = (w0 >> 48) & mask;
  out[7] = w0 >> 56;
  out[8] = (w1)&mask;
  out[9] = (w1 >> 8) & mask;
  out[10] = (w1 >> 16) & mask;
  out[11] = (w1 >> 24) & mask;
  out[12] = (w1 >> 32) & mask;
  out[13] = (w1 >> 40) & mask;
  out[14] = (w1 >> 48) & mask;
  out[15] = w1 >> 56;
  out[16] = (w2)&mask;
  out[17] = (w2 >> 8) & mask;
  out[18] = (w2 >> 16) & mask;
  out[19] = (w2 >> 24) & mask;
  out[20] = (w2 >> 32) & mask;
  out[21] = (w2 >> 40) & mask;
  out[22] = (w2 >> 48) & mask;
  out[23] = w2 >> 56;
  out[24] = (w3)&mask;
  out[25] = (w3 >> 8) & mask;
  out[26] = (w3 >> 16) & mask;
  out[27] = (w3 >> 24) & mask;
  out[28] = (w3 >> 32) & mask;
  out[29] = (w3 >> 40) & mask;
  out[30] = (w3 >> 48) & mask;
  out[31] = w3 >> 56;

  return in;
}

inline const uint8_t* unpack9_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 511ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint64_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 8;
  uint64_t w4 = util::SafeLoadAs<uint32_t>(in);
  w4 = arrow::bit_util::FromLittleEndian(w4);
  in += 4;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 9) & mask;
  out[2] = (w0 >> 18) & mask;
  out[3] = (w0 >> 27) & mask;
  out[4] = (w0 >> 36) & mask;
  out[5] = (w0 >> 45) & mask;
  out[6] = (w0 >> 54) & mask;
  out[7] = ((w0 >> 63) | (w1 << 1)) & mask;
  out[8] = (w1 >> 8) & mask;
  out[9] = (w1 >> 17) & mask;
  out[10] = (w1 >> 26) & mask;
  out[11] = (w1 >> 35) & mask;
  out[12] = (w1 >> 44) & mask;
  out[13] = (w1 >> 53) & mask;
  out[14] = ((w1 >> 62) | (w2 << 2)) & mask;
  out[15] = (w2 >> 7) & mask;
  out[16] = (w2 >> 16) & mask;
  out[17] = (w2 >> 25) & mask;
  out[18] = (w2 >> 34) & mask;
  out[19] = (w2 >> 43) & mask;
  out[20] = (w2 >> 52) & mask;
  out[21] = ((w2 >> 61) | (w3 << 3)) & mask;
  out[22] = (w3 >> 6) & mask;
  out[23] = (w3 >> 15) & mask;
  out[24] = (w3 >> 24) & mask;
  out[25] = (w3 >> 33) & mask;
  out[26] = (w3 >> 42) & mask;
  out[27] = (w3 >> 51) & mask;
  out[28] = ((w3 >> 60) | (w4 << 4)) & mask;
  out[29] = (w4 >> 5) & mask;
  out[30] = (w4 >> 14) & mask;
  out[31] = (w4 >> 23) & mask;

  return in;
}

inline const uint8_t* unpack10_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 1023ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint64_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 8;
  uint64_t w4 = util::SafeLoadAs<uint64_t>(in);
  w4 = arrow::bit_util::FromLittleEndian(w4);
  in += 8;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 10) & mask;
  out[2] = (w0 >> 20) & mask;
  out[3] = (w0 >> 30) & mask;
  out[4] = (w0 >> 40) & mask;
  out[5] = (w0 >> 50) & mask;
  out[6] = ((w0 >> 60) | (w1 << 4)) & mask;
  out[7] = (w1 >> 6) & mask;
  out[8] = (w1 >> 16) & mask;
  out[9] = (w1 >> 26) & mask;
  out[10] = (w1 >> 36) & mask;
  out[11] = (w1 >> 46) & mask;
  out[12] = ((w1 >> 56) | (w2 << 8)) & mask;
  out[13] = (w2 >> 2) & mask;
  out[14] = (w2 >> 12) & mask;
  out[15] = (w2 >> 22) & mask;
  out[16] = (w2 >> 32) & mask;
  out[17] = (w2 >> 42) & mask;
  out[18] = (w2 >> 52) & mask;
  out[19] = ((w2 >> 62) | (w3 << 2)) & mask;
  out[20] = (w3 >> 8) & mask;
  out[21] = (w3 >> 18) & mask;
  out[22] = (w3 >> 28) & mask;
  out[23] = (w3 >> 38) & mask;
  out[24] = (w3 >> 48) & mask;
  out[25] = ((w3 >> 58) | (w4 << 6)) & mask;
  out[26] = (w4 >> 4) & mask;
  out[27] = (w4 >> 14) & mask;
  out[28] = (w4 >> 24) & mask;
  out[29] = (w4 >> 34) & mask;
  out[30] = (w4 >> 44) & mask;
  out[31] = w4 >> 54;

  return in;
}

inline const uint8_t* unpack11_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 2047ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint64_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 8;
  uint64_t w4 = util::SafeLoadAs<uint64_t>(in);
  w4 = arrow::bit_util::FromLittleEndian(w4);
  in += 8;
  uint64_t w5 = util::SafeLoadAs<uint32_t>(in);
  w5 = arrow::bit_util::FromLittleEndian(w5);
  in += 4;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 11) & mask;
  out[2] = (w0 >> 22) & mask;
  out[3] = (w0 >> 33) & mask;
  out[4] = (w0 >> 44) & mask;
  out[5] = ((w0 >> 55) | (w1 << 9)) & mask;
  out[6] = (w1 >> 2) & mask;
  out[7] = (w1 >> 13) & mask;
  out[8] = (w1 >> 24) & mask;
  out[9] = (w1 >> 35) & mask;
  out[10] = (w1 >> 46) & mask;
  out[11] = ((w1 >> 57) | (w2 << 7)) & mask;
  out[12] = (w2 >> 4) & mask;
  out[13] = (w2 >> 15) & mask;
  out[14] = (w2 >> 26) & mask;
  out[15] = (w2 >> 37) & mask;
  out[16] = (w2 >> 48) & mask;
  out[17] = ((w2 >> 59) | (w3 << 5)) & mask;
  out[18] = (w3 >> 6) & mask;
  out[19] = (w3 >> 17) & mask;
  out[20] = (w3 >> 28) & mask;
  out[21] = (w3 >> 39) & mask;
  out[22] = (w3 >> 50) & mask;
  out[23] = ((w3 >> 61) | (w4 << 3)) & mask;
  out[24] = (w4 >> 8) & mask;
  out[25] = (w4 >> 19) & mask;
  out[26] = (w4 >> 30) & mask;
  out[27] = (w4 >> 41) & mask;
  out[28] = (w4 >> 52) & mask;
  out[29] = ((w4 >> 63) | (w5 << 1)) & mask;
  out[30] = (w5 >> 10) & mask;
  out[31] = (w5 >> 21) & mask;

  return in;
}

inline const uint8_t* unpack12_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 4095ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint64_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 8;
  uint64_t w4 = util::SafeLoadAs<uint64_t>(in);
  w4 = arrow::bit_util::FromLittleEndian(w4);
  in += 8;
  uint64_t w5 = util::SafeLoadAs<uint64_t>(in);
  w5 = arrow::bit_util::FromLittleEndian(w5);
  in += 8;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 12) & mask;
  out[2] = (w0 >> 24) & mask;
  out[3] = (w0 >> 36) & mask;
  out[4] = (w0 >> 48) & mask;
  out[5] = ((w0 >> 60) | (w1 << 4)) & mask;
  out[6] = (w1 >> 8) & mask;
  out[7] = (w1 >> 20) & mask;
  out[8] = (w1 >> 32) & mask;
  out[9] = (w1 >> 44) & mask;
  out[10] = ((w1 >> 56) | (w2 << 8)) & mask;
  out[11] = (w2 >> 4) & mask;
  out[12] = (w2 >> 16) & mask;
  out[13] = (w2 >> 28) & mask;
  out[14] = (w2 >> 40) & mask;
  out[15] = w2 >> 52;
  out[16] = (w3)&mask;
  out[17] = (w3 >> 12) & mask;
  out[18] = (w3 >> 24) & mask;
  out[19] = (w3 >> 36) & mask;
  out[20] = (w3 >> 48) & mask;
  out[21] = ((w3 >> 60) | (w4 << 4)) & mask;
  out[22] = (w4 >> 8) & mask;
  out[23] = (w4 >> 20) & mask;
  out[24] = (w4 >> 32) & mask;
  out[25] = (w4 >> 44) & mask;
  out[26] = ((w4 >> 56) | (w5 << 8)) & mask;
  out[27] = (w5 >> 4) & mask;
  out[28] = (w5 >> 16) & mask;
  out[29] = (w5 >> 28) & mask;
  out[30] = (w5 >> 40) & mask;
  out[31] = w5 >> 52;

  return in;
}

inline const uint8_t* unpack13_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 8191ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint64_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 8;
  uint64_t w4 = util::SafeLoadAs<uint64_t>(in);
  w4 = arrow::bit_util::FromLittleEndian(w4);
  in += 8;
  uint64_t w5 = util::SafeLoadAs<uint64_t>(in);
  w5 = arrow::bit_util::FromLittleEndian(w5);
  in += 8;
  uint64_t w6 = util::SafeLoadAs<uint32_t>(in);
  w6 = arrow::bit_util::FromLittleEndian(w6);
  in += 4;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 13) & mask;
  out[2] = (w0 >> 26) & mask;
  out[3] = (w0 >> 39) & mask;
  out[4] = ((w0 >> 52) | (w1 << 12)) & mask;
  out[5] = (w1 >> 1) & mask;
  out[6] = (w1 >> 14) & mask;
  out[7] = (w1 >> 27) & mask;
  out[8] = (w1 >> 40) & mask;
  out[9] = ((w1 >> 53) | (w2 << 11)) & mask;
  out[10] = (w2 >> 2) & mask;
  out[11] = (w2 >> 15) & mask;
  out[12] = (w2 >> 28) & mask;
  out[13] = (w2 >> 41) & mask;
  out[14] = ((w2 >> 54) | (w3 << 10)) & mask;
  out[15] = (w3 >> 3) & mask;
  out[16] = (w3 >> 16) & mask;
  out[17] = (w3 >> 29) & mask;
  out[18] = (w3 >> 42) & mask;
  out[19] = ((w3 >> 55) | (w4 << 9)) & mask;
  out[20] = (w4 >> 4) & mask;
  out[21] = (w4 >> 17) & mask;
  out[22] = (w4 >> 30) & mask;
  out[23] = (w4 >> 43) & mask;
  out[24] = ((w4 >> 56) | (w5 << 8)) & mask;
  out[25] = (w5 >> 5) & mask;
  out[26] = (w5 >> 18) & mask;
  out[27] = (w5 >> 31) & mask;
  out[28] = (w5 >> 44) & mask;
  out[29] = ((w5 >> 57) | (w6 << 7)) & mask;
  out[30] = (w6 >> 6) & mask;
  out[31] = (w6 >> 19) & mask;

  return in;
}

inline const uint8_t* unpack14_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 16383ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint64_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 8;
  uint64_t w4 = util::SafeLoadAs<uint64_t>(in);
  w4 = arrow::bit_util::FromLittleEndian(w4);
  in += 8;
  uint64_t w5 = util::SafeLoadAs<uint64_t>(in);
  w5 = arrow::bit_util::FromLittleEndian(w5);
  in += 8;
  uint64_t w6 = util::SafeLoadAs<uint64_t>(in);
  w6 = arrow::bit_util::FromLittleEndian(w6);
  in += 8;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 14) & mask;
  out[2] = (w0 >> 28) & mask;
  out[3] = (w0 >> 42) & mask;
  out[4] = ((w0 >> 56) | (w1 << 8)) & mask;
  out[5] = (w1 >> 6) & mask;
  out[6] = (w1 >> 20) & mask;
  out[7] = (w1 >> 34) & mask;
  out[8] = (w1 >> 48) & mask;
  out[9] = ((w1 >> 62) | (w2 << 2)) & mask;
  out[10] = (w2 >> 12) & mask;
  out[11] = (w2 >> 26) & mask;
  out[12] = (w2 >> 40) & mask;
  out[13] = ((w2 >> 54) | (w3 << 10)) & mask;
  out[14] = (w3 >> 4) & mask;
  out[15] = (w3 >> 18) & mask;
  out[16] = (w3 >> 32) & mask;
  out[17] = (w3 >> 46) & mask;
  out[18] = ((w3 >> 60) | (w4 << 4)) & mask;
  out[19] = (w4 >> 10) & mask;
  out[20] = (w4 >> 24) & mask;
  out[21] = (w4 >> 38) & mask;
  out[22] = ((w4 >> 52) | (w5 << 12)) & mask;
  out[23] = (w5 >> 2) & mask;
  out[24] = (w5 >> 16) & mask;
  out[25] = (w5 >> 30) & mask;
  out[26] = (w5 >> 44) & mask;
  out[27] = ((w5 >> 58) | (w6 << 6)) & mask;
  out[28] = (w6 >> 8) & mask;
  out[29] = (w6 >> 22) & mask;
  out[30] = (w6 >> 36) & mask;
  out[31] = w6 >> 50;

  return in;
}

inline const uint8_t* unpack15_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 32767ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint64_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 8;
  uint64_t w4 = util::SafeLoadAs<uint64_t>(in);
  w4 = arrow::bit_util::FromLittleEndian(w4);
  in += 8;
  uint64_t w5 = util::SafeLoadAs<uint64_t>(in);
  w5 = arrow::bit_util::FromLittleEndian(w5);
  in += 8;
  uint64_t w6 = util::SafeLoadAs<uint64_t>(in);
  w6 = arrow::bit_util::FromLittleEndian(w6);
  in += 8;
  uint64_t w7 = util::SafeLoadAs<uint32_t>(in);
  w7 = arrow::bit_util::FromLittleEndian(w7);
  in += 4;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 15) & mask;
  out[2] = (w0 >> 30) & mask;
  out[3] = (w0 >> 45) & mask;
  out[4] = ((w0 >> 60) | (w1 << 4)) & mask;
  out[5] = (w1 >> 11) & mask;
  out[6] = (w1 >> 26) & mask;
  out[7] = (w1 >> 41) & mask;
  out[8] = ((w1 >> 56) | (w2 << 8)) & mask;
  out[9] = (w2 >> 7) & mask;
  out[10] = (w2 >> 22) & mask;
  out[11] = (w2 >> 37) & mask;
  out[12] = ((w2 >> 52) | (w3 << 12)) & mask;
  out[13] = (w3 >> 3) & mask;
  out[14] = (w3 >> 18) & mask;
  out[15] = (w3 >> 33) & mask;
  out[16] = (w3 >> 48) & mask;
  out[17] = ((w3 >> 63) | (w4 << 1)) & mask;
  out[18] = (w4 >> 14) & mask;
  out[19] = (w4 >> 29) & mask;
  out[20] = (w4 >> 44) & mask;
  out[21] = ((w4 >> 59) | (w5 << 5)) & mask;
  out[22] = (w5 >> 10) & mask;
  out[23] = (w5 >> 25) & mask;
  out[24] = (w5 >> 40) & mask;
  out[25] = ((w5 >> 55) | (w6 << 9)) & mask;
  out[26] = (w6 >> 6) & mask;
  out[27] = (w6 >> 21) & mask;
  out[28] = (w6 >> 36) & mask;
  out[29] = ((w6 >> 51) | (w7 << 13)) & mask;
  out[30] = (w7 >> 2) & mask;
  out[31] = (w7 >> 17) & mask;

  return in;
}

inline const uint8_t* unpack16_16(const uint8_t* in, uint16_t* out) {
  const uint64_t mask = 65535ULL;
  uint64_t w0 = util::SafeLoadAs<uint64_t>(in);
  w0 = arrow::bit_util::FromLittleEndian(w0);
  in += 8;
  uint64_t w1 = util::SafeLoadAs<uint64_t>(in);
  w1 = arrow::bit_util::FromLittleEndian(w1);
  in += 8;
  uint64_t w2 = util::SafeLoadAs<uint64_t>(in);
  w2 = arrow::bit_util::FromLittleEndian(w2);
  in += 8;
  uint64_t w3 = util::SafeLoadAs<uint64_t>(in);
  w3 = arrow::bit_util::FromLittleEndian(w3);
  in += 8;
  uint64_t w4 = util::SafeLoadAs<uint64_t>(in);
  w4 = arrow::bit_util::FromLittleEndian(w4);
  in += 8;
  uint64_t w5 = util::SafeLoadAs<uint64_t>(in);
  w5 = arrow::bit_util::FromLittleEndian(w5);
  in += 8;
  uint64_t w6 = util::SafeLoadAs<uint64_t>(in);
  w6 = arrow::bit_util::FromLittleEndian(w6);
  in += 8;
  uint64_t w7 = util::SafeLoadAs<uint64_t>(in);
  w7 = arrow::bit_util::FromLittleEndian(w7);
  in += 8;
  out[0] = (w0)&mask;
  out[1] = (w0 >> 16) & mask;
  out[2] = (w0 >> 32) & mask;
  out[3] = w0 >> 48;
  out[4] = (w1)&mask;
  out[5] = (w1 >> 16) & mask;
  out[6] = (w1 >> 32) & mask;
  out[7] = w1 >> 48;
  out[8] = (w2)&mask;
  out[9] = (w2 >> 16) & mask;
  out[10] = (w2 >> 32) & mask;
  out[11] = w2 >> 48;
  out[12] = (w3)&mask;
  out[13] = (w3 >> 16) & mask;
  out[14] = (w3 >> 32) & mask;
  out[15] = w3 >> 48;
  out[16] = (w4)&mask;
  out[17] = (w4 >> 16) & mask;
  out[18] = (w4 >> 32) & mask;
  out[19] = w4 >> 48;
  out[20] = (w5)&mask;
  out[21] = (w5 >> 16) & mask;
  out[22] = (w5 >> 32) & mask;
  out[23] = w5 >> 48;
  out[24] = (w6)&mask;
  out[25] = (w6 >> 16) & mask;
  out[26] = (w6 >> 32) & mask;
  out[27] = w6 >> 48;
  out[28] = (w7)&mask;
  out[29] = (w7 >> 16) & mask;
  out[30] = (w7 >> 32) & mask;
  out[31] = w7 >> 48;

  return in;
}

}
}